which= c(1, 2, 5),
par(mfrow = c(2,2)) )
ggplotly(p)
# draw diagnostic plots using the plot() function. Choose the plots 1, 2 and 5
plot(my_model,
which= c(1, 2, 5),
par(mfrow = c(2,2)) )
ggplot(my_model)
ggplot(
plot(my_model,
which= c(1, 2, 5),
par(mfrow = c(2,2)) )
)
# draw diagnostic plots using the plot() function. Choose the plots 1, 2 and 5
plot(my_model,
which= c(1, 2, 5),
par(mfrow = c(2,2)) )
#load libraries
library(GGally)
library(ggplot2)
# Draw the plot
plot_data <- ggpairs(learning2014, mapping = aes(col = gender, alpha = 0.3),
lower = list(combo = wrap("facethist", bins = 20))) + theme_classic()
plot_data
#load libraries
library(GGally)
library(ggplot2)
# Draw the plot
plot_data <- ggpairs(learning2014, mapping = aes(col = gender, alpha = 0.3),
lower = list(combo = wrap("facethist", bins = 20))) + theme_classic()
plot_data
#load libraries
library(GGally)
library(ggplot2)
# Draw the plot
plot_data <- ggpairs(learning2014, mapping = aes(col = gender, alpha = 0.3),
lower = list(combo = wrap("facethist", bins = 20))) + theme_classic()
plot_data
# draw diagnostic plots using the plot() function. Choose the plots 1, 2 and 5
plot(my_model,
which= c(1, 2, 5),
par(mfrow = c(2,2)) )
library(ggthemes)
# initialize plot with data and aesthetic mapping
p1 <- ggplot(learning2014, aes(x = Attitude, y = Points))+
geom_point() +
geom_smooth(method = "lm") +
ggtitle("Student's Attitude versus exam points scored") +
theme_economist_white()
p1
install.packages("ggfortify")
library(ggfortify)
autoplot(my_model, label.size = 3)
autoplot(my_model, which= c(1, 2, 5), label.size = 3)
autoplot(my_model, which= c(1, 2, 5), ncols=3, label.size = 3)
autoplot(my_model, which= c(1, 2, 5), ncol= 3, label.size = 3)
autoplot(my_model, which= c(1, 2, 5), ncol= 1, label.size = 3)
autoplot(my_model, which= c(1, 2, 5), ncol= 1, label.size = 3) +theme_economist_white()
autoplot(my_model, which= c(1, 2, 5),  label.size = 3) +theme_economist_white()
# draw diagnostic plots using the plot() function. Choose the plots 1, 2 and 5
plot(my_model,
which= c(1, 2, 5),
par(mfrow = c(2,2)) )
library(ggfortify)
autoplot(my_model, which= c(1, 2, 5), label.size = 3) + theme_economist_white()
autoplot(my_model, which= c(1, 2, 5), label.size = 3,  colour = 'gender') + theme_economist_white()
autoplot(my_model, which= c(1, 2, 5), label.size = 3,  colour = 'Gender') + theme_economist_white()
autoplot(my_model, which= c(1, 2, 5), label.size = 3) + theme_economist_white()
autoplot(my_model, which= c(1, 2, 5)#, label.size = 3
) + theme_economist_white()
autoplot(my_model, which= c(1, 2, 5), label.size = 3
) + theme_economist_white()
autoplot(my_model, which= c(1, 2, 5))
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
autoplot(my_model, which= c(1, 2, 5), par(mfrow = c(2,2)) ) +
theme_economist_white()
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
autoplot(my_model, which= c(1, 2, 5)) +
theme_bw()
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
par(mfrow = c(1, 2))
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
par(mfrow = c(1, 3))
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
par(mfrow = c(2, 2))
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
autoplot(my_model, which= c(1, 2, 5)) +
theme_bw()
autoplot(my_model, which= c(1, 2, 5)) +
theme_economist_white()
p1 <- ggplot(learning2014, aes(x = Attitude, y = Points))+
geom_point() +
geom_smooth(method = "lm") +
ggtitle("Student's Attitude versus exam points scored") +
theme_bw()
p1
autoplot(my_model, which= c(1, 2, 5)) +
theme_bw()
# draw diagnostic plots using the plot() function. Choose the plots 1, 2 and 5
plot(my_model,
which= c(1, 2, 5),
par(mfrow = c(2,2)) )
library(ggfortify)
autoplot(my_model, which= c(1, 2, 5)) +
theme_bw()
# draw diagnostic plots using the plot() function. Choose the plots 1, 2 and 5
library(ggfortify)
autoplot(my_model, which= c(1, 2, 5)) +
theme_bw()
autoplot(my_model, which= c(1)) +
theme_bw()
autoplot(my_model, which= c(2)) +
theme_bw()
autoplot(my_model, which= 5) +
theme_bw()
plot_data <- ggpairs(learning2014, mapping = aes(col = gender, alpha = 0.3),
lower = list(combo = wrap("facethist", bins = 20))) + theme_bw()
plot_data
library(boot)
url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets"
# web address for math class data
url_math <- paste(url, "student-mat.csv", sep = "/")
# print out the address
url_math
# read the math class questionaire data into memory
math <- read.table(url_math, sep = ";" , header=TRUE)
# web address for portuguese class data
url_por <- paste(url, "student-por.csv", sep ="/")
# print out the address
url_por
# read the portuguese class questionaire data into memory
por <- read.table(url_por, sep = ";", header = TRUE)
# look at the column names of both data
colnames(math)
colnames(por)
# math and por are available
# access the dplyr library
library(dplyr)
# common columns to use as identifiers
join_by <- c("school","sex","age","address","famsize","Pstatus","Medu","Fedu","Mjob","Fjob","reason","nursery","internet")
# join the two datasets by the selected identifiers
math_por <- inner_join(math, por, by = join_by)
math_por <- inner_join(math, por, by = join_by, suffix = c(".math", ".por"))
# see the new column names
colnames(math_por)
# glimpse at the data
glimpse(math_por)
# dplyr, math_por, join_by are available
# print out the column names of 'math_por'
colnames(math_por)
# create a new data frame with only the joined columns
alc <- select(math_por, one_of(join_by))
# the columns in the datasets which were not used for joining the data
notjoined_columns <- colnames(math)[!colnames(math) %in% join_by]
# print out the columns not used for joining
notjoined_columns
# for every column name not used for joining...
for(column_name in notjoined_columns) {
# select two columns from 'math_por' with the same original name
two_columns <- select(math_por, starts_with(column_name))
# select the first column vector of those two columns
first_column <- select(two_columns, 1)[[1]]
# if that first column vector is numeric...
if(is.numeric(first_column)) {
# take a rounded average of each row of the two columns and
# add the resulting vector to the alc data frame
alc[column_name] <- round(rowMeans(two_columns))
} else { # else if it's not numeric...
# add the first column vector to the alc data frame
alc[column_name] <- first_column
}
}
# glimpse at the new combined data
glimpse(alc)
# alc is available
# access the 'tidyverse' packages dplyr and ggplot2
library(dplyr); library(ggplot2)
# define a new column alc_use by combining weekday and weekend alcohol use
alc <- mutate(alc, alc_use = (Dalc + Walc) / 2)
# initialize a plot of alcohol use
g1 <- ggplot(data = alc, aes(x = alc_use, fill= sex))
# define the plot as a bar plot and draw it
g1 + geom_bar()
# define a new logical column 'high_use'
alc <- mutate(alc, high_use = alc_use > 2)
# initialize a plot of 'high_use'
g2 <- ggplot(data = alc, aes(x= high_use) )
# draw a bar plot of high_use by sex
g2 + geom_bar() + facet_wrap("sex")
# alc is available
# access the tidyverse libraries tidyr, dplyr, ggplot2
library(tidyr); library(dplyr); library(ggplot2)
# glimpse at the alc data
glimpse(alc)
# use gather() to gather columns into key-value pairs and then glimpse() at the resulting data
gather(alc) %>% glimpse()
# draw a bar plot of each variable
gather(alc) %>%
ggplot(aes(value)) +
geom_bar() +
facet_wrap("key", scales = "free")
gather(tbl) %>%
ggplot(aes(value)) +
geom_bar() +
facet_wrap("key", scales = "free")
gather(tbl) %>%
ggplot(aes(value)) +
geom_bar() +
facet_wrap("key", scales = "free") + theme_bw()
# alc is available
# access the tidyverse libraries dplyr and ggplot2
library(dplyr); library(ggplot2)
# produce summary statistics by group
alc %>%
group_by(sex, high_use) %>%
summarise(count = n(), mean_grade = mean(G3))
library(ggplot2)
# initialize a plot of high_use and G3
g1 <- ggplot(alc, aes(x = high_use, y = G3, col = sex))
# define the plot as a boxplot and draw it
g1 + geom_boxplot() + ylab("grade")
# initialise a plot of high_use and absences
g2 <- ggplot(alc, aes(x = high_use, y = absences, col = sex))
# define the plot as a boxplot and draw it
g2 + geom_boxplot() + ggtitle("Student absences by alcohol consumption and sex")
# alc is available
# find the model with glm()
m <- glm(high_use ~ failures + absences +sex, data = alc, family = "binomial")
# print out a summary of the model
summary(m)
# print out the coefficients of the model
coef(m)
# alc and dlyr are available
# find the model with glm()
m <- glm(high_use ~ failures + absences + sex, data = alc, family = "binomial")
# compute odds ratios (OR)
OR <- coef(m) %>% exp
# compute confidence intervals (CI)
CI <- confint(m) %>% exp
# print out the odds ratios with their confidence intervals
cbind(OR, CI)
# alc, dplyr are available
# fit the model
m <- glm(high_use ~ failures + absences + sex, data = alc, family = "binomial")
# predict() the probability of high_use
probabilities <- predict(m, type = "response")
# add the predicted probabilities to 'alc'
alc <- mutate(alc, probability = probabilities)
# use the probabilities to make a prediction of high_use
alc <- mutate(alc, prediction = probabilities > 0.5 )
# see the last ten original classes, predicted probabilities, and class predictions
select(alc, failures, absences, sex, high_use, probability, prediction) %>% head(10)
# tabulate the target variable versus the predictions
table(high_use = alc$high_use, prediction = alc$prediction)
# alc is available
# access dplyr and ggplot2
library(dplyr); library(ggplot2)
# initialize a plot of 'high_use' versus 'probability' in 'alc'
g <- ggplot(alc, aes(x = probability, y = high_use, col= prediction))
# define the geom as points and draw the plot
g + geom_point()
# tabulate the target variable versus the predictions
table(high_use = alc$high_use, prediction = alc$prediction) %>%
prop.table() %>%
addmargins
# the logistic regression model m and dataset alc with predictions are available
# define a loss function (mean prediction error)
loss_func <- function(class, prob) {
n_wrong <- abs(class - prob) > 0.5
mean(n_wrong)
}
# call loss_func to compute the average number of wrong predictions in the (training) data
loss_func(class = alc$high_use, prob = alc$probability)
# the logistic regression model m and dataset alc (with predictions) are available
# define a loss function (average prediction error)
loss_func <- function(class, prob) {
n_wrong <- abs(class - prob) > 0.5
mean(n_wrong)
}
# compute the average number of wrong predictions in the (training) data
loss_func(alc$high_use, alc$probability)
# K-fold cross-validation
library(boot)
cv <- cv.glm(data = alc, cost = loss_func, glmfit = m, K = 10)
# average number of wrong predictions in the cross validation
cv$delta[1]
url <- "http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets"
library(dplyr)
url_math <- paste(url, "student-mat.csv", sep = "/")
url_math
math <- read.table(url_math, sep = ";" , header=TRUE)
url_por <- paste(url, "student-por.csv", sep ="/")
url_por
por <- read.table(url_por, sep = ";", header = TRUE)
colnames(math)
colnames(por)
setwd( "/Users/dtsallos/Desktop/OneDrive - University of Helsinki/GitHub/IODS-project/data")
math <- read.table(url_math, sep = ";" , header=TRUE)
math
math <- read.table("student-mat.csv", sep = ";" , header=TRUE)
por <- read.table("student-por.csv", sep = ";", header = TRUE)
colnames(math)
colnames(por)
str(por)
str(math)
join_by <- c("school", "sex", "age", "address", "famsize", "Pstatus", "Medu", "Fedu", "Mjob", "Fjob", "reason", "nursery","internet")
join_by <- c("school", "sex", "age", "address", "famsize", "Pstatus", "Medu", "Fedu", "Mjob", "Fjob", "reason", "nursery","internet")
join_by
math_por <- inner_join(math, por, by = join_by)
math_por <- inner_join(math, por, by = join_by, suffix = c(".math", ".por"))
math_por
colnames(math_por)
glimpse(math_por)
glimpse(math_por)
alc <- select(math_por, one_of(join_by))
notjoined_columns <- colnames(math)[!colnames(math) %in% join_by]
notjoined_columns
library(dplyr)
#set working directory
setwd( "/Users/dtsallos/Desktop/OneDrive - University of Helsinki/GitHub/IODS-project/data")
# read the math class questionaire data into memory
math <- read.table("student-mat.csv", sep = ";" , header=TRUE)
# read the portuguese class questionaire data into memory
por <- read.table("student-por.csv", sep = ";", header = TRUE)
# look at the structure of both data
str(math)
str(por)
# look at the column names of both data
colnames(math)
colnames(por)
# join tables using the following variables as student identifiers
join_by <- c("school", "sex", "age", "address", "famsize", "Pstatus", "Medu", "Fedu", "Mjob", "Fjob", "reason", "nursery","internet")
# join the two datasets by the selected identifiers
math_por <- inner_join(math, por, by = join_by)
math_por <- inner_join(math, por, by = join_by, suffix = c(".math", ".por"))
# see the new column names
colnames(math_por)
# glimpse at the data
glimpse(math_por)
# create a new data frame with only the joined columns
alc <- select(math_por, one_of(join_by))
# the columns in the datasets which were not used for joining the data
notjoined_columns <- colnames(math)[!colnames(math) %in% join_by] # duplicated data
# print out the columns not used for joining
notjoined_columns
alc
# for every column name not used for joining...
for(column_name in notjoined_columns) {
# select two columns from 'math_por' with the same original name
two_columns <- select(math_por, starts_with(column_name))
# select the first column vector of those two columns
first_column <- select(two_columns, 1)[[1]]
# if that first column vector is numeric...
if(is.numeric(first_column)) {
# take a rounded average of each row of the two columns and
# add the resulting vector to the alc data frame
alc[column_name] <- round(rowMeans(two_columns))
} else { # else if it's not numeric...
# add the first column vector to the alc data frame
alc[column_name] <- first_column
}
}
# glimpse at the new combined data
glimpse(alc)
math_por <- inner_join(math, por, by = join_by, suffix = c(".math", ".por"))
math_por
alc <- select(math_por, one_of(join_by))
notjoined_columns <- colnames(math)[!colnames(math) %in% join_by] # duplicated data
notjoined_columns
for(column_name in notjoined_columns) {
# select two columns from 'math_por' with the same original name
two_columns <- select(math_por, starts_with(column_name))
# select the first column vector of those two columns
first_column <- select(two_columns, 1)[[1]]
# if that first column vector is numeric...
if(is.numeric(first_column)) {
# take a rounded average of each row of the two columns and
# add the resulting vector to the alc data frame
alc[column_name] <- round(rowMeans(two_columns))
} else { # else if it's not numeric...
# add the first column vector to the alc data frame
alc[column_name] <- first_column
}
}
glimpse(alc)
# define a new column alc_use by combining weekday and weekend alcohol use
alc <- mutate(alc, alc_use = (Dalc + Walc) / 2)
# initialize a plot of alcohol use
g1 <- ggplot(data = alc, aes(x = alc_use, fill= sex))
# define the plot as a bar plot and draw it
g1 + geom_bar()
# define a new logical column 'high_use'
alc <- mutate(alc, high_use = alc_use > 2)
# initialize a plot of 'high_use'
g2 <- ggplot(data = alc, aes(x= high_use) )
# draw a bar plot of high_use by sex
g2 + geom_bar() + facet_wrap("sex")
# define a new column alc_use by combining weekday and weekend alcohol use
alc <- mutate(alc, alc_use = (Dalc + Walc) / 2)
# initialize a plot of alcohol use
g1 <- ggplot(data = alc, aes(x = alc_use, fill= sex))
# define the plot as a bar plot and draw it
g1 + geom_bar()
# define a new logical column 'high_use'
alc <- mutate(alc, high_use = alc_use > 2)
# initialize a plot of 'high_use'
g2 <- ggplot(data = alc, aes(x= high_use) )
# draw a bar plot of high_use by sex
g2 + geom_bar() + facet_wrap("sex")
glimpse(alc)
alc <- mutate(alc, alc_use = mean(Dalc, Walc) )
alc
alc <- mutate(alc, alc_use = (Dalc + Walc) / 2)
alc
library(dplyr)
#set working directory
setwd( "/Users/dtsallos/Desktop/OneDrive - University of Helsinki/GitHub/IODS-project/data")
# read the math class questionaire data into memory
math <- read.table("student-mat.csv", sep = ";" , header=TRUE)
# read the portuguese class questionaire data into memory
por <- read.table("student-por.csv", sep = ";", header = TRUE)
# look at the structure of both data
str(math)
str(por)
# look at the column names of both data
colnames(math)
colnames(por)
# join tables using the following variables as student identifiers
join_by <- c("school", "sex", "age", "address", "famsize", "Pstatus", "Medu", "Fedu", "Mjob", "Fjob", "reason", "nursery","internet")
# join the two datasets by the selected identifiers
math_por <- inner_join(math, por, by = join_by, suffix = c(".math", ".por"))
# see the new column names
colnames(math_por)
# glimpse at the data
glimpse(math_por)
# create a new data frame with only the joined columns
alc <- select(math_por, one_of(join_by))
# the columns in the datasets which were not used for joining the data
notjoined_columns <- colnames(math)[!colnames(math) %in% join_by] # duplicated data
# print out the columns not used for joining
notjoined_columns
# for every column name not used for joining...
for(column_name in notjoined_columns) {
# select two columns from 'math_por' with the same original name
two_columns <- select(math_por, starts_with(column_name))
# select the first column vector of those two columns
first_column <- select(two_columns, 1)[[1]]
# if that first column vector is numeric...
if(is.numeric(first_column)) {
# take a rounded average of each row of the two columns and
# add the resulting vector to the alc data frame
alc[column_name] <- round(rowMeans(two_columns))
} else { # else if it's not numeric...
# add the first column vector to the alc data frame
alc[column_name] <- first_column
}
}
# glimpse at the new combined data
glimpse(alc)
# Take the average of the answers related to weekday and weekend alcohol consumption to create a new column 'alc_use'
# to the joined data. Then use 'alc_use' to create a new logical column 'high_use' which is TRUE for students for which 'alc_use'
# is greater than 2 (and FALSE otherwise). (1 point)
# define a new column alc_use by combining weekday and weekend alcohol use
alc <- mutate(alc, alc_use = (Dalc + Walc) / 2)
glimpse(alc)
alc
alc <- mutate(alc, high_use = alc_use > 2)
alc
glimpse(alc)
dim(alc)
alc[column_name]
dim(alc) #The joined data should now have 382 observations of 35 variables.
write.csv(alc, file = "student-combined.csv" )
library(ggcyto)
install.packages("ggcyto")
library(flowWorkspace)
install.packages("flowWorkspace")
flowDataPath <- system.file("extdata", package = "flowWorkspaceData")
wsfile <- list.files(flowDataPath, pattern="manual.xml",full = TRUE)
wsfile
flowDataPath
library(BioC2015OpenCyto)
install.packages("ggcyto")
source("https://bioconductor.org/biocLite.R")
biocLite("ggcyto")
library(ggcyto)
library(BioC2015OpenCyto)
install.packages(BioC2015OpenCyto)
install.packages("BioC2015OpenCyto")
source("https://bioconductor.org/biocLite.R")
biocLite("BioC2015OpenCyto")
library(ggcyto)
library(BioC2015OpenCyto)
install_github("gfinak/BioC2015OpenCyto")
library(devtools)
install_github("gfinak/BioC2015OpenCyto")
library(ggcyto)
library(BioC2015OpenCyto)
bioclite("openCyto")
biocLite("openCyto")
install_github("gfinak/BioC2015OpenCyto")
library(BioC2015OpenCyto)
library(BioC2015OpenCyto)
data(tbdata)
